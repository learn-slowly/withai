name: Update Index Files

on:
  push:
    branches:
      - main

jobs:
  update-indexes:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytz
          
      - name: Update index files
        run: |
          python3 << 'EOF'
          import os
          import re
          from datetime import datetime
          import pytz

          def get_korean_time():
              kst = pytz.timezone('Asia/Seoul')
              now = datetime.now(kst)
              return now.strftime('%Y-%m-%d %H:%M:%S KST')

          def update_index_file(index_path, new_files):
              if not os.path.exists(index_path):
                  return
                  
              with open(index_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              # H1 제목 찾기
              h1_match = re.search(r'^# .*$', content, re.MULTILINE)
              if not h1_match:
                  return
                  
              h1_end = h1_match.end()
              
              # 현재 시간 추가
              current_time = get_korean_time()
              time_update = f"\n#### Last updated: {current_time}\n"
              
              # 기존의 Last updated 라인이 있다면 제거
              content = re.sub(r'\n#### Last updated:.*?\n', '', content, flags=re.MULTILINE)
              
              # 기존 링크 찾기
              existing_links = set()
              for match in re.finditer(r'\[(\d{4}-\d{2}-\d{2})\]', content):
                  existing_links.add(match.group(1))
              
              # 새로운 파일 링크 생성 (중복 제외)
              new_links = ""
              for file in sorted(new_files, reverse=True):
                  date = os.path.splitext(os.path.basename(file))[0]
                  if re.match(r'^\d{8}$', date):
                      formatted_date = f"{date[:4]}-{date[4:6]}-{date[6:]}"
                      if formatted_date not in existing_links:  # 중복 체크
                          new_links += f"\n- [{formatted_date}]({file})\n"
              
              # 컨텐츠 업데이트 (기존 내용 유지)
              updated_content = content[:h1_end] + time_update + new_links + content[h1_end:]
              
              # 혹시 모를 중복 제거를 위한 추가 처리
              updated_content = re.sub(r'(\n#### Last updated:.*?\n).*?(\n#### Last updated:.*?\n)', r'\2', updated_content, flags=re.DOTALL)
              
              with open(index_path, 'w', encoding='utf-8') as f:
                  f.write(updated_content)

          def update_foreign_lang_index(index_path, jp_files, en_files):
              if not os.path.exists(index_path):
                  return
                  
              with open(index_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              # H1 제목 찾기
              h1_match = re.search(r'^# .*$', content, re.MULTILINE)
              if not h1_match:
                  return
                  
              h1_end = h1_match.end()
              
              # 현재 시간 추가
              current_time = get_korean_time()
              time_update = f"\n#### Last updated: {current_time}\n"
              
              # 기존의 Last updated 라인이 있다면 제거
              content = re.sub(r'\n#### Last updated:.*?\n', '', content, flags=re.MULTILINE)
              
              # 기존 내용에서 ## Japanese와 ## English 섹션 찾기
              sections = content[h1_end:].split('\n## ')
              
              # 기존 링크 찾기
              existing_jp_links = set()
              existing_en_links = set()
              for match in re.finditer(r'\[(\d{4}-\d{2}-\d{2})\]\(foreign-lang/jp/.*?\)', content):
                  existing_jp_links.add(match.group(1))
              for match in re.finditer(r'\[(\d{4}-\d{2}-\d{2})\]\(foreign-lang/en/.*?\)', content):
                  existing_en_links.add(match.group(1))
              
              # 새로운 파일 링크 생성 (중복 제외)
              jp_links = ""
              for file in sorted(jp_files, reverse=True):
                  date = os.path.splitext(os.path.basename(file))[0]
                  if re.match(r'^\d{8}$', date):
                      formatted_date = f"{date[:4]}-{date[4:6]}-{date[6:]}"
                      if formatted_date not in existing_jp_links:  # 중복 체크
                          jp_links += f"\n- [{formatted_date}](foreign-lang/jp/{file})\n"
                      
              en_links = ""
              for file in sorted(en_files, reverse=True):
                  date = os.path.splitext(os.path.basename(file))[0]
                  if re.match(r'^\d{8}$', date):
                      formatted_date = f"{date[:4]}-{date[4:6]}-{date[6:]}"
                      if formatted_date not in existing_en_links:  # 중복 체크
                          en_links += f"\n- [{formatted_date}](foreign-lang/en/{file})\n"
              
              # 각 섹션 업데이트 (기존 내용 유지)
              updated_sections = []
              for section in sections:
                  if section.startswith('Japanese'):
                      updated_sections.append(f"Japanese{jp_links}{section[8:]}")
                  elif section.startswith('English'):
                      updated_sections.append(f"English{en_links}{section[7:]}")
                  else:
                      updated_sections.append(section)
              
              # 컨텐츠 업데이트
              updated_content = content[:h1_end] + time_update + '\n## '.join(updated_sections)
              
              # 혹시 모를 중복 제거를 위한 추가 처리
              updated_content = re.sub(r'(\n#### Last updated:.*?\n).*?(\n#### Last updated:.*?\n)', r'\2', updated_content, flags=re.DOTALL)
              
              with open(index_path, 'w', encoding='utf-8') as f:
                  f.write(updated_content)

          def update_readme():
              readme_path = 'README.md'
              if not os.path.exists(readme_path):
                  return
                  
              with open(readme_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              current_time = get_korean_time()
              time_update = f"\n#### Last updated: {current_time}\n"
              
              # 기존의 Last updated 라인이 있다면 제거
              content = re.sub(r'\n#### Last updated:.*?\n', '', content, flags=re.MULTILINE)
              
              # 파일 끝에 새로운 업데이트 시간 추가
              updated_content = content.rstrip() + time_update
              
              with open(readme_path, 'w', encoding='utf-8') as f:
                  f.write(updated_content)

          # 각 폴더의 마크다운 파일 수집
          content_prod_files = [f for f in os.listdir('content-production') if f.endswith('.md') and f != 'index.md']
          webdev_files = [f for f in os.listdir('webdev') if f.endswith('.md') and f != 'index.md']
          jp_files = [f for f in os.listdir('foreign-lang/jp') if f.endswith('.md')]
          en_files = [f for f in os.listdir('foreign-lang/en') if f.endswith('.md')]

          # 인덱스 파일 업데이트
          update_index_file('content-production/index.md', content_prod_files)
          update_index_file('webdev/index.md', webdev_files)
          update_foreign_lang_index('foreign-lang/index.md', jp_files, en_files)
          update_readme()
          EOF

      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "Update index files" || exit 0
          git push
