name: Update Index Files

on:
  push:
    branches:
      - main

jobs:
  update-indexes:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytz
          
      - name: Update index files
        run: |
          python3 << 'EOF'
          import os
          import re
          from datetime import datetime
          import pytz

          def get_korean_time():
              kst = pytz.timezone('Asia/Seoul')
              now = datetime.now(kst)
              return now.strftime('%Y-%m-%d %H:%M:%S KST')

          def update_index_file(index_path, new_files):
              if not os.path.exists(index_path):
                  return
                  
              with open(index_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              # H1 제목 찾기
              h1_match = re.search(r'^# .*$', content, re.MULTILINE)
              if not h1_match:
                  return
                  
              h1_end = h1_match.end()
              
              # 현재 시간 추가
              current_time = get_korean_time()
              time_update = f"\n#### Last updated: {current_time}\n"
              
              # 기존의 Last updated 라인이 있다면 제거
              content = re.sub(r'\n#### Last updated:.*?\n', '', content, flags=re.MULTILINE)
              
              # 기존 링크 찾기
              existing_links = set()
              for match in re.finditer(r'\[(\d{4}-\d{2}-\d{2})\]', content):
                  existing_links.add(match.group(1))
              
              # 새로운 파일 링크 생성 (중복 제외)
              new_links = ""
              for file in sorted(new_files, reverse=True):
                  date = os.path.splitext(os.path.basename(file))[0]
                  if re.match(r'^\d{8}$', date):
                      formatted_date = f"{date[:4]}-{date[4:6]}-{date[6:]}"
                      if formatted_date not in existing_links:  # 중복 체크
                          new_links += f"\n- [{formatted_date}]({file})\n"
              
              # 컨텐츠 업데이트 (기존 내용 유지)
              updated_content = content[:h1_end] + time_update + new_links + content[h1_end:]
              
              # 혹시 모를 중복 제거를 위한 추가 처리
              updated_content = re.sub(r'(\n#### Last updated:.*?\n).*?(\n#### Last updated:.*?\n)', r'\2', updated_content, flags=re.DOTALL)
              
              with open(index_path, 'w', encoding='utf-8') as f:
                  f.write(updated_content)

          def update_foreign_lang_index(index_path, jp_files, en_files):
              if not os.path.exists(index_path):
                  return
                  
              with open(index_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              # H1 제목 찾기
              h1_match = re.search(r'^# .*$', content, re.MULTILINE)
              if not h1_match:
                  return
                  
              h1_end = h1_match.end()
              
              # 현재 시간 추가
              current_time = get_korean_time()
              time_update = f"\n### Last updated: {current_time}\n"
              
              # 기존의 Last updated 라인이 있다면 제거
              content = re.sub(r'\n### Last updated:.*?\n', '', content, flags=re.MULTILINE)
              
              # English와 Japanese 섹션 찾기
              en_section = re.search(r'\n## English\n', content)
              jp_section = re.search(r'\n## Japanese\n', content)
              
              if en_section:
                  en_pos = en_section.end()
                  # 새로운 영어 파일 링크 추가
                  for file in sorted(en_files, reverse=True):
                      date = os.path.splitext(os.path.basename(file))[0]
                      if re.match(r'^\d{8}$', date):
                          formatted_date = f"{date[:4]}-{date[4:6]}-{date[6:]}"
                          link = f"\n- [{formatted_date}](en/{date}.md)\n"
                          content = content[:en_pos] + link + content[en_pos:]
              
              if jp_section:
                  jp_pos = jp_section.end()
                  # 새로운 일본어 파일 링크 추가
                  for file in sorted(jp_files, reverse=True):
                      date = os.path.splitext(os.path.basename(file))[0]
                      if re.match(r'^\d{8}$', date):
                          formatted_date = f"{date[:4]}-{date[4:6]}-{date[6:]}"
                          link = f"\n- [{formatted_date}](jp/{date}.md)\n"
                          content = content[:jp_pos] + link + content[jp_pos:]
              
              # Last updated 시간을 h1 바로 아래에 추가
              updated_content = content[:h1_end] + time_update + content[h1_end:]
              
              with open(index_path, 'w', encoding='utf-8') as f:
                  f.write(updated_content)

          def update_readme():
              # 대소문자 구분 없이 파일 찾기
              for filename in os.listdir('.'):
                  if filename.lower() == 'readme.md':
                      readme_path = filename
                      break
              else:
                  return  # README.md 파일을 찾지 못함
              
              with open(readme_path, 'r', encoding='utf-8') as f:
                  content = f.read()
              
              current_time = get_korean_time()
              time_update = f"\n#### Last updated: {current_time}\n"
              
              # 파일 끝의 Last updated 찾아서 제거
              content = re.sub(r'\n#### Last updated:.*?$', '', content, flags=re.MULTILINE | re.DOTALL)
              
              # 내용 끝에 불필요한 개행 제거 후 새로운 시간 추가
              updated_content = content.rstrip() + time_update
              
              # 디버깅을 위한 출력
              print(f"Updating {readme_path} with new timestamp")
              
              with open(readme_path, 'w', encoding='utf-8') as f:
                  f.write(updated_content)

          # 각 폴더의 마크다운 파일 수집
          content_prod_files = [f for f in os.listdir('content-production') if f.endswith('.md') and f != 'index.md']
          webdev_files = [f for f in os.listdir('webdev') if f.endswith('.md') and f != 'index.md']
          jp_files = [f for f in os.listdir('foreign-lang/jp') if f.endswith('.md')]
          en_files = [f for f in os.listdir('foreign-lang/en') if f.endswith('.md')]

          # 인덱스 파일 업데이트
          update_index_file('content-production/index.md', content_prod_files)
          update_index_file('webdev/index.md', webdev_files)
          update_foreign_lang_index('foreign-lang/index.md', jp_files, en_files)
          update_readme()
          EOF

      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "Update index files" || exit 0
          git push
